// SQL Files Management Utilities

export interface SQLFile {
  name: string;
  content: string;
  size: number;
  lastModified: string;
  status?: 'idle' | 'running' | 'success' | 'error';
  result?: any;
  error?: string;
  executionTime?: number;
}

// –í —Ä–µ–∞–ª—å–Ω–æ–π —Å—Ä–µ–¥–µ —ç—Ç–æ –±—ã —Ä–∞–±–æ—Ç–∞–ª–æ —Å —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–æ–π
// –ü–æ–∫–∞ —á—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ
export async function loadSQLFiles(): Promise<SQLFile[]> {
  try {
    // –û—Ç—Ä–∏–º—É—î–º–æ —Å–ø–∏—Å–æ–∫ –≤–∏–¥–∞–ª–µ–Ω–∏—Ö —Ñ–∞–π–ª—ñ–≤ –∑ localStorage
    const deletedFiles = JSON.parse(localStorage.getItem('deletedSQLFiles') || '[]') as string[];
    
    // –í production —ç—Ç–æ –±—ã –±—ã–ª API –≤—ã–∑–æ–≤ –∫ —Å–µ—Ä–≤–µ—Ä—É
    // –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ñ–∞–π–ª—ã
    const staticFiles: SQLFile[] = [
      {
        name: 'example_analytics.sql',
        content: await getFileContent('example_analytics.sql'),
        size: 2048,
        lastModified: new Date().toISOString(),
        status: 'idle'
      },
      {
        name: 'seo_urls_setup.sql',
        content: await getFileContent('seo_urls_setup.sql'), 
        size: 1024,
        lastModified: new Date(Date.now() - 86400000).toISOString(),
        status: 'idle'
      },
      {
        name: 'apply_seo_migration.sql',
        content: await getFileContent('apply_seo_migration.sql'),
        size: 512,
        lastModified: new Date(Date.now() - 172800000).toISOString(), 
        status: 'idle'
      },
      {
        name: 'database_schema_analysis.sql',
        content: await getFileContent('database_schema_analysis.sql'),
        size: 4096,
        lastModified: new Date().toISOString(),
        status: 'idle'
      },
      {
        name: 'quick_schema_check.sql',
        content: await getFileContent('quick_schema_check.sql'),
        size: 2048,
        lastModified: new Date().toISOString(),
        status: 'idle'
      },
      {
        name: '20250128_create_schema_views.sql',
        content: await getFileContent('20250128_create_schema_views.sql'),
        size: 8192,
        lastModified: new Date().toISOString(),
        status: 'idle'
      },
      {
        name: '20250128_improve_performance.sql',
        content: await getFileContent('20250128_improve_performance.sql'),
        size: 6144,
        lastModified: new Date().toISOString(),
        status: 'idle'
      },
      {
        name: '20250128_create_db_analysis_functions.sql',
        content: await getFileContent('20250128_create_db_analysis_functions.sql'),
        size: 12288,
        lastModified: new Date().toISOString(),
        status: 'idle'
      },
      {
        name: '20250128_create_exec_sql_function.sql',
        content: await getFileContent('20250128_create_exec_sql_function.sql'),
        size: 16384,
        lastModified: new Date().toISOString(),
        status: 'idle'
      },
      {
        name: 'database_full_analysis.sql',
        content: await getFileContent('database_full_analysis.sql'),
        size: 8192,
        lastModified: new Date().toISOString(),
        status: 'idle'
      },
      {
        name: '20250128_create_full_database_manager.sql',
        content: await getFileContent('20250128_create_full_database_manager.sql'),
        size: 32768,
        lastModified: new Date().toISOString(),
        status: 'idle'
      },
      {
        name: 'debug_database_manager.sql',
        content: await getFileContent('debug_database_manager.sql'),
        size: 4096,
        lastModified: new Date().toISOString(),
        status: 'idle'
      },
      {
        name: 'simple_database_manager.sql',
        content: await getFileContent('simple_database_manager.sql'),
        size: 8192,
        lastModified: new Date().toISOString(),
        status: 'idle'
      },
      {
        name: 'test_exec_sql.sql',
        content: await getFileContent('test_exec_sql.sql'),
        size: 2048,
        lastModified: new Date().toISOString(),
        status: 'idle'
      },
      {
        name: 'create_exec_sql_function.sql',
        content: await getFileContent('create_exec_sql_function.sql'),
        size: 4096,
        lastModified: new Date().toISOString(),
        status: 'idle'
      },
      {
        name: 'all_in_one_database_setup.sql',
        content: await getFileContent('all_in_one_database_setup.sql'),
        size: 8192,
        lastModified: new Date().toISOString(),
        status: 'idle'
      }
    ];

    // –§—ñ–ª—å—Ç—Ä—É—î–º–æ –≤–∏–¥–∞–ª–µ–Ω—ñ —Ñ–∞–π–ª–∏
    const filteredFiles = staticFiles.filter(file => !deletedFiles.includes(file.name));
    
    return filteredFiles;
  } catch (error) {
    console.error('Error loading SQL files:', error);
    return [];
  }
}

async function getFileContent(fileName: string): Promise<string> {
  // –°—Ç–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–æ–≤ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
  const contents: { [key: string]: string } = {
    'example_analytics.sql': `-- Example Analytics Query
-- –ê–Ω–∞–ª–∏–∑ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏ –æ–±—ä—è–≤–ª–µ–Ω–∏–π

-- 1. –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ –º–µ—Å—è—Ü–∞–º
SELECT 
  DATE_TRUNC('month', created_at) as month,
  COUNT(*) as users_count,
  COUNT(*) FILTER (WHERE email_confirmed_at IS NOT NULL) as confirmed_users
FROM auth.users 
WHERE created_at >= NOW() - INTERVAL '6 months'
GROUP BY month 
ORDER BY month DESC;

-- 2. –¢–æ–ø –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –æ–±—ä—è–≤–ª–µ–Ω–∏–π
SELECT 
  c.name as category_name,
  COUNT(l.*) as listings_count,
  COUNT(l.*) FILTER (WHERE l.status = 'active') as active_listings,
  ROUND(AVG(l.price), 2) as avg_price
FROM categories c
LEFT JOIN listings l ON c.id = l.category_id
GROUP BY c.id, c.name
ORDER BY listings_count DESC
LIMIT 10;`,

    'seo_urls_setup.sql': `-- SEO URLs Setup
-- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ SEO-–¥—Ä—É–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö URL

CREATE OR REPLACE FUNCTION setup_seo_urls() 
RETURNS void AS $$
BEGIN
  -- –°–æ–∑–¥–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ slug
  CREATE OR REPLACE FUNCTION generate_slug(input_text TEXT)
  RETURNS TEXT AS $func$
  BEGIN
    RETURN lower(
      regexp_replace(
        regexp_replace(input_text, '[^a-zA-Z0-9–∞-—è—ë\\s-]', '', 'gi'),
        '\\s+', '-', 'g'
      )
    );
  END;
  $func$ LANGUAGE plpgsql;

  -- –î–æ–±–∞–≤–ª—è–µ–º slug –∫–æ–ª–æ–Ω–∫—É –∫ listings –µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'listings' AND column_name = 'slug'
  ) THEN
    ALTER TABLE listings ADD COLUMN slug TEXT;
    CREATE UNIQUE INDEX IF NOT EXISTS idx_listings_slug ON listings(slug);
  END IF;

  -- –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∑–∞–ø–∏—Å–∏
  UPDATE listings 
  SET slug = generate_slug(title || '-' || id::text)
  WHERE slug IS NULL;

END;
$$ LANGUAGE plpgsql;`,

    'apply_seo_migration.sql': `-- Apply SEO Migration
-- –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ SEO –º–∏–≥—Ä–∞—Ü–∏–∏

-- –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫—É SEO URLs
SELECT setup_seo_urls();

-- –°–æ–∑–¥–∞–µ–º –∏–Ω–¥–µ–∫—Å—ã –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
CREATE INDEX IF NOT EXISTS idx_listings_slug_status ON listings(slug, status);
CREATE INDEX IF NOT EXISTS idx_listings_category_slug ON listings(category_id, slug);

-- –î–æ–±–∞–≤–ª—è–µ–º —Ç—Ä–∏–≥–≥–µ—Ä –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ slug
CREATE OR REPLACE FUNCTION auto_generate_slug()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.slug IS NULL OR NEW.slug = '' THEN
    NEW.slug := generate_slug(NEW.title || '-' || NEW.id::text);
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_auto_generate_slug ON listings;
CREATE TRIGGER trigger_auto_generate_slug 
  BEFORE INSERT OR UPDATE ON listings
  FOR EACH ROW EXECUTE FUNCTION auto_generate_slug();

-- –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ç–∞–±–ª–∏—Ü
ANALYZE listings;

SELECT 'SEO migration applied successfully' as result;`,

    'database_schema_analysis.sql': `-- –ü–æ–≤–Ω–∏–π –∞–Ω–∞–ª—ñ–∑ —Å—Ö–µ–º–∏ –±–∞–∑–∏ –¥–∞–Ω–∏—Ö
-- –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Ü–µ–π —Ñ–∞–π–ª –¥–ª—è –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –≤–∏–≤—á–µ–Ω–Ω—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –ë–î

-- 1. –í–°–Ü –¢–ê–ë–õ–ò–¶–Ü –í –ë–î
SELECT tablename as "üìÅ –¢–∞–±–ª–∏—Ü—ñ" FROM pg_tables WHERE schemaname = 'public' ORDER BY tablename;

-- 2. –ö–û–õ–û–ù–ö–ò –ö–û–ñ–ù–û–á –¢–ê–ë–õ–ò–¶–Ü  
SELECT 
  table_name as "üèóÔ∏è –¢–∞–±–ª–∏—Ü—è",
  column_name as "üìã –ö–æ–ª–æ–Ω–∫–∞", 
  data_type as "üìä –¢–∏–ø",
  is_nullable as "‚ùì NULL",
  column_default as "üîß –ó–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º"
FROM information_schema.columns 
WHERE table_schema = 'public' 
ORDER BY table_name, ordinal_position;

-- 3. FOREIGN KEY –ó–í'–Ø–ó–ö–ò
SELECT 
  tc.table_name as "üìù –¢–∞–±–ª–∏—Ü—è",
  kcu.column_name as "üîó –ö–æ–ª–æ–Ω–∫–∞",
  ccu.table_name as "üéØ –ó–æ–≤–Ω—ñ—à–Ω—è —Ç–∞–±–ª–∏—Ü—è",
  ccu.column_name as "üéØ –ó–æ–≤–Ω—ñ—à–Ω—è –∫–æ–ª–æ–Ω–∫–∞"
FROM information_schema.table_constraints tc
JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage ccu ON ccu.constraint_name = tc.constraint_name
WHERE tc.constraint_type = 'FOREIGN KEY' AND tc.table_schema = 'public';`,

    'quick_schema_check.sql': `-- –®–≤–∏–¥–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –æ—Å–Ω–æ–≤–Ω–∏—Ö —Ç–∞–±–ª–∏—Ü—å
-- –ó–∞–ø—É—Å—Ç—ñ—Ç—å –¥–ª—è —à–≤–∏–¥–∫–æ–≥–æ –æ–≥–ª—è–¥—É –ë–î

-- –°–ø–∏—Å–æ–∫ –≤—Å—ñ—Ö —Ç–∞–±–ª–∏—Ü—å
SELECT 'üìã –¢–ê–ë–õ–ò–¶–Ü –í –ë–î:' as info;
SELECT tablename FROM pg_tables WHERE schemaname = 'public' ORDER BY tablename;

-- –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –æ—Å–Ω–æ–≤–Ω–∏—Ö —Ç–∞–±–ª–∏—Ü—å OLX
SELECT 'üîç –ü–ï–†–ï–í–Ü–†–ö–ê –û–°–ù–û–í–ù–ò–• –¢–ê–ë–õ–ò–¶–¨:' as info;

SELECT 
  CASE WHEN EXISTS(SELECT 1 FROM pg_tables WHERE tablename = 'profiles') 
    THEN '‚úÖ profiles (–∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ)' 
    ELSE '‚ùå profiles –≤—ñ–¥—Å—É—Ç–Ω—è' END as "–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ";

SELECT 
  CASE WHEN EXISTS(SELECT 1 FROM pg_tables WHERE tablename = 'listings') 
    THEN '‚úÖ listings (–æ–≥–æ–ª–æ—à–µ–Ω–Ω—è)' 
    ELSE '‚ùå listings –≤—ñ–¥—Å—É—Ç–Ω—è' END as "–û–≥–æ–ª–æ—à–µ–Ω–Ω—è";

SELECT 
  CASE WHEN EXISTS(SELECT 1 FROM pg_tables WHERE tablename = 'categories') 
    THEN '‚úÖ categories (–∫–∞—Ç–µ–≥–æ—Ä—ñ—ó)' 
    ELSE '‚ùå categories –≤—ñ–¥—Å—É—Ç–Ω—è' END as "–ö–∞—Ç–µ–≥–æ—Ä—ñ—ó";`,

    '20250128_create_schema_views.sql': `-- –ú–Ü–ì–†–ê–¶–Ü–Ø: –°—Ç–≤–æ—Ä–µ–Ω–Ω—è view –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É —Å—Ö–µ–º–∏
-- –¶—è –º—ñ–≥—Ä–∞—Ü—ñ—è —Å—Ç–≤–æ—Ä—é—î –∑—Ä—É—á–Ω—ñ view —Ç–∞ —Ñ—É–Ω–∫—Ü—ñ—ó –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É –ë–î

-- 1. View –∑–∞–≥–∞–ª—å–Ω–æ–≥–æ –æ–≥–ª—è–¥—É —Ç–∞–±–ª–∏—Ü—å
CREATE OR REPLACE VIEW v_schema_overview AS
SELECT 
  table_name as —Ç–∞–±–ª–∏—Ü—è,
  (SELECT count(*) FROM information_schema.columns WHERE table_name = t.table_name) as –∫–æ–ª–æ–Ω–æ–∫
FROM information_schema.tables t
WHERE t.table_schema = 'public' AND t.table_type = 'BASE TABLE'
ORDER BY table_name;

-- 2. –§—É–Ω–∫—Ü—ñ—è –æ–ø–∏—Å—É —Ç–∞–±–ª–∏—Ü—ñ
CREATE OR REPLACE FUNCTION describe_table(table_name_param TEXT)
RETURNS TABLE (–∫–æ–ª–æ–Ω–∫–∞ TEXT, —Ç–∏–ø TEXT, nullable TEXT, –∑–∞_–∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º TEXT)
LANGUAGE plpgsql AS $$
BEGIN
  RETURN QUERY
  SELECT c.column_name, c.data_type, c.is_nullable, c.column_default
  FROM information_schema.columns c
  WHERE c.table_schema = 'public' AND c.table_name = table_name_param
  ORDER BY c.ordinal_position;
END; $$;

SELECT 'Schema views —Å—Ç–≤–æ—Ä–µ–Ω–æ —É—Å–ø—ñ—à–Ω–æ!' as result;`,

    '20250128_improve_performance.sql': `-- –ú–Ü–ì–†–ê–¶–Ü–Ø: –ü–æ–∫—Ä–∞—â–µ–Ω–Ω—è –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ
-- –î–æ–¥–∞—î —ñ–Ω–¥–µ–∫—Å–∏ —Ç–∞ –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó

-- –Ü–Ω–¥–µ–∫—Å–∏ –¥–ª—è listings (—è–∫—â–æ —ñ—Å–Ω—É—î)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'listings') THEN
    CREATE INDEX IF NOT EXISTS idx_listings_status_created ON listings (status, created_at DESC);
    CREATE INDEX IF NOT EXISTS idx_listings_category ON listings (category_id, status);
    RAISE NOTICE '–Ü–Ω–¥–µ–∫—Å–∏ –¥–ª—è listings —Å—Ç–≤–æ—Ä–µ–Ω–æ';
  END IF;
END $$;

-- –Ü–Ω–¥–µ–∫—Å–∏ –¥–ª—è profiles (—è–∫—â–æ —ñ—Å–Ω—É—î)  
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'profiles') THEN
    CREATE INDEX IF NOT EXISTS idx_profiles_email ON profiles (email);
    RAISE NOTICE '–Ü–Ω–¥–µ–∫—Å–∏ –¥–ª—è profiles —Å—Ç–≤–æ—Ä–µ–Ω–æ';
  END IF;
END $$;

-- –†–æ–∑—à–∏—Ä–µ–Ω–Ω—è –¥–ª—è —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –ø–æ—à—É–∫—É
CREATE EXTENSION IF NOT EXISTS pg_trgm;

SELECT '–ú—ñ–≥—Ä–∞—Ü—ñ—è –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!' as result;`,

    '20250128_create_db_analysis_functions.sql': `-- –ú–Ü–ì–†–ê–¶–Ü–Ø: RPC —Ñ—É–Ω–∫—Ü—ñ—ó –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É –ë–î
-- –°—Ç–≤–æ—Ä—é—î –±–µ–∑–ø–µ—á–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ–≥–æ –∞–Ω–∞–ª—ñ–∑—É —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –ë–î

-- 1. –§—É–Ω–∫—Ü—ñ—è —Å–ø–∏—Å–∫—É —Ç–∞–±–ª–∏—Ü—å
CREATE OR REPLACE FUNCTION public.get_tables_info()
RETURNS TABLE (table_name TEXT, column_count BIGINT, has_primary_key BOOLEAN, estimated_rows BIGINT)
LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  RETURN QUERY
  SELECT t.tablename::TEXT, 
    (SELECT count(*) FROM information_schema.columns c WHERE c.table_name = t.tablename)::BIGINT,
    EXISTS(SELECT 1 FROM information_schema.table_constraints tc WHERE tc.table_name = t.tablename AND tc.constraint_type = 'PRIMARY KEY'),
    COALESCE(s.n_live_tup, 0)::BIGINT
  FROM pg_tables t
  LEFT JOIN pg_stat_user_tables s ON t.tablename = s.relname
  WHERE t.schemaname = 'public' ORDER BY t.tablename;
END; $$;

-- 2. –§—É–Ω–∫—Ü—ñ—è –∫–æ–ª–æ–Ω–æ–∫ —Ç–∞–±–ª–∏—Ü—ñ
CREATE OR REPLACE FUNCTION public.get_table_columns(table_name_param TEXT)
RETURNS TABLE (column_name TEXT, data_type TEXT, is_nullable BOOLEAN, column_default TEXT, is_primary_key BOOLEAN)
LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  RETURN QUERY
  SELECT c.column_name::TEXT, c.data_type::TEXT,
    CASE WHEN c.is_nullable = 'YES' THEN TRUE ELSE FALSE END,
    c.column_default::TEXT,
    EXISTS(SELECT 1 FROM information_schema.table_constraints tc
      JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
      WHERE tc.table_name = table_name_param AND tc.constraint_type = 'PRIMARY KEY' AND kcu.column_name = c.column_name)
  FROM information_schema.columns c
  WHERE c.table_schema = 'public' AND c.table_name = table_name_param
  ORDER BY c.ordinal_position;
END; $$;

-- 3. –§—É–Ω–∫—Ü—ñ—è –ø–æ–≤–Ω–æ–≥–æ –∞–Ω–∞–ª—ñ–∑—É
CREATE OR REPLACE FUNCTION public.analyze_database_schema()
RETURNS JSON LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE result JSON;
BEGIN
  SELECT json_build_object(
    'tables', (SELECT json_agg(row_to_json(t)) FROM public.get_tables_info() t),
    'analyzed_at', now(),
    'total_tables', (SELECT count(*) FROM public.get_tables_info())
  ) INTO result;
  RETURN result;
END; $$;

-- –ü—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø—É
GRANT EXECUTE ON FUNCTION public.get_tables_info() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_table_columns(TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.analyze_database_schema() TO authenticated;

SELECT 'RPC —Ñ—É–Ω–∫—Ü—ñ—ó —Å—Ç–≤–æ—Ä–µ–Ω–æ!' as result;`,

    '20250128_create_exec_sql_function.sql': `-- –ú–Ü–ì–†–ê–¶–Ü–Ø: –§—É–Ω–∫—Ü—ñ—è exec_sql –¥–ª—è SQL Manager
-- –í–∏—Ä—ñ—à—É—î –ø–æ–º–∏–ª–∫—É: Could not find the function public.exec_sql(sql_query) in the schema cache

-- –ì–æ–ª–æ–≤–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –¥–ª—è –≤–∏–∫–æ–Ω–∞–Ω–Ω—è SQL –∑–∞–ø–∏—Ç—ñ–≤
CREATE OR REPLACE FUNCTION public.exec_sql(sql_query TEXT)
RETURNS JSON LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  result_data JSON;
  affected_rows INTEGER := 0;
  execution_time_ms INTEGER;
  execution_start TIMESTAMP;
  query_type TEXT;
BEGIN
  execution_start := clock_timestamp();
  query_type := UPPER(TRIM(SPLIT_PART(sql_query, ' ', 1)));
  
  -- –û–±–º–µ–∂–µ–Ω–Ω—è –±–µ–∑–ø–µ–∫–∏
  IF query_type IN ('DROP', 'TRUNCATE', 'DELETE') AND sql_query NOT LIKE '%WHERE%' THEN
    RETURN json_build_object('success', false, 'message', '–ù–µ–±–µ–∑–ø–µ—á–Ω–∞ –æ–ø–µ—Ä–∞—Ü—ñ—è –±–µ–∑ WHERE —É–º–æ–≤–∏');
  END IF;
  
  BEGIN
    IF query_type = 'SELECT' OR query_type = 'WITH' THEN
      EXECUTE 'SELECT json_agg(row_to_json(t)) FROM (' || sql_query || ') t' INTO result_data;
      EXECUTE 'SELECT COUNT(*) FROM (' || sql_query || ') t' INTO affected_rows;
    ELSE
      EXECUTE sql_query;
      GET DIAGNOSTICS affected_rows = ROW_COUNT;
      result_data := json_build_object('message', '–ó–∞–ø–∏—Ç –≤–∏–∫–æ–Ω–∞–Ω–æ —É—Å–ø—ñ—à–Ω–æ');
    END IF;
    
    execution_time_ms := EXTRACT(MILLISECONDS FROM (clock_timestamp() - execution_start))::INTEGER;
    
    RETURN json_build_object(
      'success', true,
      'data', COALESCE(result_data, '[]'::json),
      'affected_rows', affected_rows,
      'execution_time_ms', execution_time_ms,
      'message', '–ó–∞–ø–∏—Ç –≤–∏–∫–æ–Ω–∞–Ω–æ —É—Å–ø—ñ—à–Ω–æ'
    );
    
  EXCEPTION WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'message', '–ü–æ–º–∏–ª–∫–∞: ' || SQLERRM,
      'error', SQLSTATE
    );
  END;
END; $$;

-- –î–æ–¥–∞—Ç–∫–æ–≤—ñ —Ñ—É–Ω–∫—Ü—ñ—ó
CREATE OR REPLACE FUNCTION public.exec_select(sql_query TEXT, row_limit INTEGER DEFAULT 100)
RETURNS JSON LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE result_data JSON; total_rows INTEGER;
BEGIN
  EXECUTE 'SELECT COUNT(*) FROM (' || sql_query || ') t' INTO total_rows;
  EXECUTE 'SELECT json_agg(row_to_json(t)) FROM (' || sql_query || ' LIMIT ' || row_limit || ') t' INTO result_data;
  RETURN json_build_object('success', true, 'data', result_data, 'total_rows', total_rows);
EXCEPTION WHEN OTHERS THEN
  RETURN json_build_object('success', false, 'message', SQLERRM);
END; $$;

-- –ü—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø—É
GRANT EXECUTE ON FUNCTION public.exec_sql(TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.exec_select(TEXT, INTEGER) TO authenticated;

SELECT '–§—É–Ω–∫—Ü—ñ—è exec_sql —Å—Ç–≤–æ—Ä–µ–Ω–∞ —É—Å–ø—ñ—à–Ω–æ!' as result;`,

    'database_full_analysis.sql': `-- –ü–û–í–ù–ò–ô –ê–ù–ê–õ–Ü–ó –°–¢–†–£–ö–¢–£–†–ò –ë–î
-- –î–µ—Ç–∞–ª—å–Ω–∏–π –æ–≥–ª—è–¥ –≤—Å—ñ—Ö —Ç–∞–±–ª–∏—Ü—å, –∫–æ–ª–æ–Ω–æ–∫, —ñ–Ω–¥–µ–∫—Å—ñ–≤ —Ç–∞ –∑–≤'—è–∑–∫—ñ–≤

-- 1. –ó–∞–≥–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
SELECT 
  '–¢–∞–±–ª–∏—Ü—ñ' as —Ç–∏–ø,
  count(*) as –∫—ñ–ª—å–∫—ñ—Å—Ç—å
FROM pg_tables WHERE schemaname = 'public'
UNION ALL
SELECT '–§—É–Ω–∫—Ü—ñ—ó', count(*) FROM pg_proc p JOIN pg_namespace n ON p.pronamespace = n.oid WHERE n.nspname = 'public';

-- 2. –°–ø–∏—Å–æ–∫ —Ç–∞–±–ª–∏—Ü—å –∑ –¥–µ—Ç–∞–ª—è–º–∏
SELECT 
  t.tablename as "üìÅ –¢–∞–±–ª–∏—Ü—è",
  (SELECT count(*) FROM information_schema.columns c WHERE c.table_name = t.tablename) as "üìã –ö–æ–ª–æ–Ω–æ–∫",
  COALESCE(s.n_live_tup, 0) as "üìä –†—è–¥–∫—ñ–≤",
  pg_size_pretty(pg_total_relation_size('public.'||t.tablename)) as "üíæ –†–æ–∑–º—ñ—Ä"
FROM pg_tables t
LEFT JOIN pg_stat_user_tables s ON t.tablename = s.relname
WHERE t.schemaname = 'public'
ORDER BY s.n_live_tup DESC NULLS LAST;

-- 3. –î–µ—Ç–∞–ª—å–Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∫–æ–ª–æ–Ω–æ–∫
SELECT 
  table_name as "üèóÔ∏è –¢–∞–±–ª–∏—Ü—è",
  column_name as "üìù –ö–æ–ª–æ–Ω–∫–∞",
  data_type as "üìä –¢–∏–ø",
  is_nullable as "‚ùì NULL",
  column_default as "üîß –ó–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º"
FROM information_schema.columns
WHERE table_schema = 'public'
ORDER BY table_name, ordinal_position;

-- 4. Foreign Key –∑–≤'—è–∑–∫–∏
SELECT 
  tc.table_name as "üìù –¢–∞–±–ª–∏—Ü—è",
  kcu.column_name as "üìã –ö–æ–ª–æ–Ω–∫–∞", 
  ccu.table_name as "üéØ –ó–æ–≤–Ω—ñ—à–Ω—è —Ç–∞–±–ª–∏—Ü—è",
  ccu.column_name as "üéØ –ó–æ–≤–Ω—ñ—à–Ω—è –∫–æ–ª–æ–Ω–∫–∞"
FROM information_schema.table_constraints tc
JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage ccu ON ccu.constraint_name = tc.constraint_name
WHERE tc.constraint_type = 'FOREIGN KEY' AND tc.table_schema = 'public';

-- 5. –Ü–Ω–¥–µ–∫—Å–∏
SELECT 
  tablename as "üìÅ –¢–∞–±–ª–∏—Ü—è",
  indexname as "‚ö° –Ü–Ω–¥–µ–∫—Å",
  CASE WHEN indexdef LIKE '%UNIQUE%' THEN '–£–Ω—ñ–∫–∞–ª—å–Ω–∏–π' ELSE '–ó–≤–∏—á–∞–π–Ω–∏–π' END as "–¢–∏–ø"
FROM pg_indexes 
WHERE schemaname = 'public'
ORDER BY tablename;

-- 6. –ü—ñ–¥—Å—É–º–æ–∫
SELECT 
  (SELECT count(*) FROM pg_tables WHERE schemaname = 'public') as "üìÅ –í—Å—å–æ–≥–æ —Ç–∞–±–ª–∏—Ü—å",
  (SELECT count(*) FROM information_schema.columns WHERE table_schema = 'public') as "üìã –í—Å—å–æ–≥–æ –∫–æ–ª–æ–Ω–æ–∫",
  pg_size_pretty(pg_database_size(current_database())) as "üíæ –†–æ–∑–º—ñ—Ä –ë–î";`,

    '20250128_create_full_database_manager.sql': `-- üóÑÔ∏è –ü–û–í–ù–û–¶–Ü–ù–ù–ò–ô DATABASE MANAGER
-- –°—Ç–≤–æ—Ä—é—î RPC —Ñ—É–Ω–∫—Ü—ñ—ó –¥–ª—è –ø–æ–≤–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –±–∞–∑–æ—é –¥–∞–Ω–∏—Ö
-- üìä –ü–µ—Ä–µ–≥–ª—è–¥ —Ç–∞–±–ª–∏—Ü—å, —Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö, —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è —Ñ—É–Ω–∫—Ü—ñ—è–º–∏

-- 1. –°–ü–ò–°–û–ö –í–°–Ü–• –¢–ê–ë–õ–ò–¶–¨ –ó –î–ï–¢–ê–õ–Ø–ú–ò
CREATE OR REPLACE FUNCTION public.get_all_tables()
RETURNS TABLE (
  table_name TEXT,
  row_count BIGINT,
  table_size TEXT,
  description TEXT
)
LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  RETURN QUERY
  SELECT 
    t.tablename::TEXT,
    COALESCE(s.n_live_tup, 0) as row_count,
    pg_size_pretty(pg_total_relation_size(quote_ident(t.tablename)::regclass))::TEXT,
    COALESCE(d.description, '–ù–µ–º–∞—î –æ–ø–∏—Å—É')::TEXT
  FROM pg_tables t
  LEFT JOIN pg_stat_user_tables s ON t.tablename = s.relname
  LEFT JOIN pg_description d ON d.objoid = quote_ident(t.tablename)::regclass
  WHERE t.schemaname = 'public'
  ORDER BY COALESCE(s.n_live_tup, 0) DESC;
END; $$;

-- 2. –°–¢–†–£–ö–¢–£–†–ê –¢–ê–ë–õ–ò–¶–Ü –ó FOREIGN KEYS
CREATE OR REPLACE FUNCTION public.get_table_structure(table_name_param TEXT)
RETURNS TABLE (
  column_name TEXT,
  data_type TEXT,
  is_nullable TEXT,
  column_default TEXT,
  is_primary_key BOOLEAN,
  is_foreign_key BOOLEAN,
  foreign_table TEXT,
  foreign_column TEXT
)
LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  RETURN QUERY SELECT 
    c.column_name::TEXT,
    c.data_type::TEXT,
    c.is_nullable::TEXT,
    COALESCE(c.column_default, '')::TEXT,
    CASE WHEN pk.column_name IS NOT NULL THEN true ELSE false END,
    CASE WHEN fk.column_name IS NOT NULL THEN true ELSE false END,
    COALESCE(fk.foreign_table_name, '')::TEXT,
    COALESCE(fk.foreign_column_name, '')::TEXT
  FROM information_schema.columns c
  LEFT JOIN (SELECT ku.column_name FROM information_schema.table_constraints tc
    JOIN information_schema.key_column_usage ku ON tc.constraint_name = ku.constraint_name
    WHERE tc.constraint_type = 'PRIMARY KEY' AND tc.table_name = table_name_param) pk 
    ON c.column_name = pk.column_name
  LEFT JOIN (SELECT ku.column_name, ccu.table_name AS foreign_table_name, ccu.column_name AS foreign_column_name
    FROM information_schema.table_constraints tc
    JOIN information_schema.key_column_usage ku ON tc.constraint_name = ku.constraint_name
    JOIN information_schema.constraint_column_usage ccu ON tc.constraint_name = ccu.constraint_name
    WHERE tc.constraint_type = 'FOREIGN KEY' AND tc.table_name = table_name_param) fk 
    ON c.column_name = fk.column_name
  WHERE c.table_name = table_name_param AND c.table_schema = 'public'
  ORDER BY c.ordinal_position;
END; $$;

-- 3. –û–¢–†–ò–ú–ê–ù–ù–Ø –î–ê–ù–ò–• –ó –ü–ê–ì–Ü–ù–ê–¶–Ü–Ñ–Æ
CREATE OR REPLACE FUNCTION public.get_table_data(
  table_name_param TEXT,
  page_number INT DEFAULT 1,
  page_size INT DEFAULT 50,
  search_query TEXT DEFAULT '',
  order_column TEXT DEFAULT '',
  order_direction TEXT DEFAULT 'ASC'
)
RETURNS TABLE (data JSONB, total_count BIGINT, page_count INT)
LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  offset_val INT;
  total_rows BIGINT;
  sql_query TEXT;
BEGIN
  offset_val := (page_number - 1) * page_size;
  
  -- –ü—ñ–¥—Ä–∞—Ö—É–Ω–æ–∫ –∑–∞–≥–∞–ª—å–Ω–æ—ó –∫—ñ–ª—å–∫–æ—Å—Ç—ñ
  EXECUTE format('SELECT COUNT(*) FROM %I', table_name_param) INTO total_rows;
  
  -- –û—Å–Ω–æ–≤–Ω–∏–π –∑–∞–ø–∏—Ç
  sql_query := format('SELECT json_agg(row_to_json(%I.*)) FROM (SELECT * FROM %I LIMIT %s OFFSET %s) %I',
    table_name_param, table_name_param, page_size, offset_val, table_name_param);
  
  RETURN QUERY SELECT 
    COALESCE((SELECT json_agg FROM (EXECUTE sql_query) AS t(json_agg)), '[]'::jsonb),
    total_rows,
    CEIL(total_rows::NUMERIC / page_size)::INT;
END; $$;

-- –ü–†–ê–í–ê –î–û–°–¢–£–ü–£
GRANT EXECUTE ON FUNCTION public.get_all_tables() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_table_structure(TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_table_data(TEXT, INT, INT, TEXT, TEXT, TEXT) TO authenticated;

SELECT '‚úÖ Database Manager RPC —Ñ—É–Ω–∫—Ü—ñ—ó —Å—Ç–≤–æ—Ä–µ–Ω—ñ —É—Å–ø—ñ—à–Ω–æ!' as result;`,

    'debug_database_manager.sql': `-- üîç –î–Ü–ê–ì–ù–û–°–¢–ò–ö–ê DATABASE MANAGER
-- –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ —Å—Ç–≤–æ—Ä–µ–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó —Ç–∞ —á–∏ –ø—Ä–∞—Ü—é—é—Ç—å

-- 1. –ü–ï–†–ï–í–Ü–†–Ø–Ñ–ú–û –ß–ò –Ü–°–ù–£–Æ–¢–¨ –§–£–ù–ö–¶–Ü–á
SELECT 
  '–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Ñ—É–Ω–∫—Ü—ñ–π Database Manager:' as step,
  COUNT(*) as created_functions
FROM pg_proc p
JOIN pg_namespace n ON p.pronamespace = n.oid
WHERE n.nspname = 'public' 
  AND p.proname IN ('get_all_tables', 'get_table_structure', 'get_table_data', 'get_all_functions');

-- 2. –°–ü–ò–°–û–ö –°–¢–í–û–†–ï–ù–ò–• –§–£–ù–ö–¶–Ü–ô
SELECT 
  '–°—Ç–≤–æ—Ä–µ–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó:' as info,
  p.proname as function_name,
  pg_get_function_arguments(p.oid) as arguments
FROM pg_proc p
JOIN pg_namespace n ON p.pronamespace = n.oid
WHERE n.nspname = 'public' 
  AND p.proname LIKE '%get_%'
ORDER BY p.proname;

-- 3. –ü–†–û–°–¢–ò–ô –¢–ï–°–¢ –¢–ê–ë–õ–ò–¶–¨ –ß–ï–†–ï–ó –°–¢–ê–ù–î–ê–†–¢–ù–Ü –ó–ê–ü–ò–¢–ò
SELECT 
  '–ü—Ä—è–º–∏–π –∑–∞–ø–∏—Ç —Ç–∞–±–ª–∏—Ü—å:' as direct_test,
  schemaname,
  tablename,
  hasindexes,
  hasrules,
  hastriggers
FROM pg_tables 
WHERE schemaname = 'public'
ORDER BY tablename
LIMIT 10;

-- 4. –ü–ï–†–ï–í–Ü–†–Ø–Ñ–ú–û –ü–†–ê–í–ê –î–û–°–¢–£–ü–£
SELECT 
  '–ü—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø—É –Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—ó:' as permissions,
  p.proname,
  has_function_privilege('authenticated', p.oid, 'EXECUTE') as can_execute
FROM pg_proc p
JOIN pg_namespace n ON p.pronamespace = n.oid
WHERE n.nspname = 'public' 
  AND p.proname IN ('get_all_tables', 'get_table_structure', 'get_table_data', 'get_all_functions');

-- 5. –¢–ï–°–¢ –í–ò–ö–õ–ò–ö–£ get_all_tables
SELECT * FROM public.get_all_tables() LIMIT 5;`,

    'simple_database_manager.sql': `-- üîß –°–ü–†–û–©–ï–ù–ê –í–ï–†–°–Ü–Ø DATABASE MANAGER
-- –ë–∞–∑–æ–≤—ñ —Ñ—É–Ω–∫—Ü—ñ—ó —è–∫—ñ —Ç–æ—á–Ω–æ –ø—Ä–∞—Ü—é–≤–∞—Ç–∏–º—É—Ç—å

-- 1. –ü–†–û–°–¢–ê –§–£–ù–ö–¶–Ü–Ø –î–õ–Ø –û–¢–†–ò–ú–ê–ù–ù–Ø –¢–ê–ë–õ–ò–¶–¨
CREATE OR REPLACE FUNCTION public.get_simple_tables()
RETURNS TABLE (
  table_name TEXT,
  row_count BIGINT,
  table_size TEXT,
  description TEXT
)
LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  RETURN QUERY
  SELECT 
    t.table_name::TEXT,
    0::BIGINT as row_count,
    '–ù–µ–≤—ñ–¥–æ–º–æ'::TEXT as table_size,
    '–ë–∞–∑–æ–≤–∞ —Ç–∞–±–ª–∏—Ü—è'::TEXT as description
  FROM information_schema.tables t
  WHERE t.table_schema = 'public'
    AND t.table_type = 'BASE TABLE'
  ORDER BY t.table_name;
END; $$;

-- 2. –ü–†–û–°–¢–ê –§–£–ù–ö–¶–Ü–Ø –î–õ–Ø –°–¢–†–£–ö–¢–£–†–ò –¢–ê–ë–õ–ò–¶–Ü
CREATE OR REPLACE FUNCTION public.get_simple_structure(table_name_param TEXT)
RETURNS TABLE (
  column_name TEXT,
  data_type TEXT,
  is_nullable TEXT,
  column_default TEXT,
  is_primary_key BOOLEAN,
  is_foreign_key BOOLEAN,
  foreign_table TEXT,
  foreign_column TEXT
)
LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  RETURN QUERY
  SELECT 
    c.column_name::TEXT,
    c.data_type::TEXT,
    c.is_nullable::TEXT,
    COALESCE(c.column_default, '')::TEXT,
    false::BOOLEAN as is_primary_key,
    false::BOOLEAN as is_foreign_key,
    ''::TEXT as foreign_table,
    ''::TEXT as foreign_column
  FROM information_schema.columns c
  WHERE c.table_name = table_name_param
    AND c.table_schema = 'public'
  ORDER BY c.ordinal_position;
END; $$;

-- 3. –ü–†–û–°–¢–ê –§–£–ù–ö–¶–Ü–Ø –î–õ–Ø –î–ê–ù–ò–• –¢–ê–ë–õ–ò–¶–Ü
CREATE OR REPLACE FUNCTION public.get_simple_data(
  table_name_param TEXT,
  page_number INT DEFAULT 1,
  page_size INT DEFAULT 50
)
RETURNS TABLE (data JSONB, total_count BIGINT, page_count INT)
LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  offset_val INT;
  sql_query TEXT;
  result_data JSONB;
BEGIN
  offset_val := (page_number - 1) * page_size;
  
  sql_query := format(
    'SELECT json_agg(row_to_json(t.*)) FROM (SELECT * FROM %I LIMIT %s OFFSET %s) t',
    table_name_param, page_size, offset_val
  );
  
  EXECUTE sql_query INTO result_data;
  
  RETURN QUERY SELECT 
    COALESCE(result_data, '[]'::jsonb) as data,
    100::BIGINT as total_count,
    1::INT as page_count;
END; $$;

-- –ü–†–ê–í–ê –î–û–°–¢–£–ü–£
GRANT EXECUTE ON FUNCTION public.get_simple_tables() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_simple_structure(TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_simple_data(TEXT, INT, INT) TO authenticated;

-- –¢–ï–°–¢
SELECT '–°–ø—Ä–æ—â–µ–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó —Å—Ç–≤–æ—Ä–µ–Ω—ñ!' as result;
SELECT * FROM public.get_simple_tables() LIMIT 5;`,

    'test_exec_sql.sql': `-- üß™ –¢–ï–°–¢ –§–£–ù–ö–¶–Ü–á exec_sql
-- –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ –ø—Ä–∞—Ü—é—î –≤–∏–∫–æ–Ω–∞–Ω–Ω—è SQL —á–µ—Ä–µ–∑ RPC

-- 1. –ü–†–û–°–¢–ò–ô –¢–ï–°–¢
SELECT '–¢–µ—Å—Ç exec_sql –ø—Ä–∞—Ü—é—î!' as test_message, NOW() as current_time;

-- 2. –ü–ï–†–ï–í–Ü–†–ö–ê –Ü–°–ù–£–í–ê–ù–ù–Ø exec_sql –§–£–ù–ö–¶–Ü–á
SELECT 
  'exec_sql function check:' as info,
  CASE 
    WHEN EXISTS (
      SELECT 1 FROM pg_proc p 
      JOIN pg_namespace n ON p.pronamespace = n.oid 
      WHERE n.nspname = 'public' AND p.proname = 'exec_sql'
    ) 
    THEN '‚úÖ exec_sql —Ñ—É–Ω–∫—Ü—ñ—è —ñ—Å–Ω—É—î' 
    ELSE '‚ùå exec_sql —Ñ—É–Ω–∫—Ü—ñ—è –ù–ï —ñ—Å–Ω—É—î' 
  END as status;

-- 3. –°–ü–ò–°–û–ö –í–°–Ü–• PUBLIC –§–£–ù–ö–¶–Ü–ô
SELECT 
  'Available functions:' as info,
  p.proname as function_name,
  pg_get_function_arguments(p.oid) as arguments
FROM pg_proc p
JOIN pg_namespace n ON p.pronamespace = n.oid
WHERE n.nspname = 'public' 
  AND p.proname NOT LIKE 'pg_%'
ORDER BY p.proname;

-- 4. –¢–ï–°–¢ –°–¢–í–û–†–ï–ù–ù–Ø –ü–†–û–°–¢–û–á –§–£–ù–ö–¶–Ü–á
CREATE OR REPLACE FUNCTION public.test_function()
RETURNS TEXT LANGUAGE sql AS $$
  SELECT 'Test function created successfully!' as result;
$$;

-- 5. –í–ò–ö–õ–ò–ö –¢–ï–°–¢–û–í–û–á –§–£–ù–ö–¶–Ü–á
SELECT public.test_function() as test_result;`,

    'create_exec_sql_function.sql': `-- üîß –°–¢–í–û–†–ï–ù–ù–Ø –§–£–ù–ö–¶–Ü–á exec_sql
-- –û—Å–Ω–æ–≤–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –¥–ª—è –≤–∏–∫–æ–Ω–∞–Ω–Ω—è SQL –∑–∞–ø–∏—Ç—ñ–≤ —á–µ—Ä–µ–∑ RPC
-- –û–ë–û–í'–Ø–ó–ö–û–í–û –≤–∏–∫–æ–Ω–∞–π—Ç–µ —Ü–µ–π —Ñ–∞–π–ª –ü–ï–†–®–ò–ú!

-- 1. –°–¢–í–û–†–Æ–Ñ–ú–û exec_sql –§–£–ù–ö–¶–Ü–Æ
CREATE OR REPLACE FUNCTION public.exec_sql(sql_query TEXT)
RETURNS JSON LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE
  result JSON; row_count_val INTEGER; start_time TIMESTAMPTZ; execution_time INTEGER;
BEGIN
  start_time := clock_timestamp();
  EXECUTE sql_query;
  GET DIAGNOSTICS row_count_val = ROW_COUNT;
  execution_time := EXTRACT(MILLISECONDS FROM (clock_timestamp() - start_time))::INTEGER;
  
  RETURN json_build_object('success', true, 'message', 'SQL –≤–∏–∫–æ–Ω–∞–Ω–æ —É—Å–ø—ñ—à–Ω–æ', 'rows_affected', row_count_val, 'execution_time', execution_time);
EXCEPTION WHEN others THEN
  execution_time := EXTRACT(MILLISECONDS FROM (clock_timestamp() - start_time))::INTEGER;
  RETURN json_build_object('success', false, 'error', SQLERRM, 'message', '–ü–æ–º–∏–ª–∫–∞ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è SQL', 'execution_time', execution_time);
END; $$;

-- 2. –ù–ê–î–ê–Ñ–ú–û –ü–†–ê–í–ê –î–û–°–¢–£–ü–£
GRANT EXECUTE ON FUNCTION public.exec_sql(TEXT) TO authenticated;

-- 3. –¢–ï–°–¢–£–Ñ–ú–û –§–£–ù–ö–¶–Ü–Æ
SELECT 'exec_sql —Ñ—É–Ω–∫—Ü—ñ—è —Å—Ç–≤–æ—Ä–µ–Ω–∞ —É—Å–ø—ñ—à–Ω–æ!' as status;
SELECT public.exec_sql('SELECT ''–¢–µ—Å—Ç —É—Å–ø—ñ—à–Ω–∏–π!'' as test_message') as test_result;
SELECT '‚úÖ –ì–û–¢–û–í–û! –¢–µ–ø–µ—Ä –º–æ–∂–µ—Ç–µ –≤–∏–∫–æ–Ω—É–≤–∞—Ç–∏ SQL —Ñ–∞–π–ª–∏ —á–µ—Ä–µ–∑ –§–∞–π–ª –ú–µ–Ω–µ–¥–∂–µ—Ä!' as final_message;`,

    'all_in_one_database_setup.sql': `-- üöÄ –í–°–ï –í –û–î–ù–û–ú–£ - –ü–û–í–ù–ê –ù–ê–°–¢–†–û–ô–ö–ê DATABASE MANAGER
-- –¶–µ–π —Ñ–∞–π–ª —Å—Ç–≤–æ—Ä—é—î –í–°–ï —â–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ –¥–ª—è —Ä–æ–±–æ—Ç–∏ Database Manager
-- –í–∏–∫–æ–Ω–∞–π—Ç–µ –¢–Ü–õ–¨–ö–ò –¶–ï–ô –§–ê–ô–õ —ñ –≤—Å–µ –∑–∞–ø—Ä–∞—Ü—é—î!

-- 1. –°–¢–í–û–†–Æ–Ñ–ú–û exec_sql –§–£–ù–ö–¶–Ü–Æ
CREATE OR REPLACE FUNCTION public.exec_sql(sql_query TEXT)
RETURNS JSON LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE result JSON; row_count_val INTEGER; start_time TIMESTAMPTZ; execution_time INTEGER;
BEGIN
  start_time := clock_timestamp(); EXECUTE sql_query; GET DIAGNOSTICS row_count_val = ROW_COUNT;
  execution_time := EXTRACT(MILLISECONDS FROM (clock_timestamp() - start_time))::INTEGER;
  RETURN json_build_object('success', true, 'message', 'SQL –≤–∏–∫–æ–Ω–∞–Ω–æ —É—Å–ø—ñ—à–Ω–æ', 'rows_affected', row_count_val, 'execution_time', execution_time);
EXCEPTION WHEN others THEN
  execution_time := EXTRACT(MILLISECONDS FROM (clock_timestamp() - start_time))::INTEGER;
  RETURN json_build_object('success', false, 'error', SQLERRM, 'message', '–ü–æ–º–∏–ª–∫–∞ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è SQL', 'execution_time', execution_time);
END; $$;

-- 2. DATABASE MANAGER RPC –§–£–ù–ö–¶–Ü–á
CREATE OR REPLACE FUNCTION public.get_simple_tables()
RETURNS TABLE (table_name TEXT, row_count BIGINT, table_size TEXT, description TEXT)
LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  RETURN QUERY SELECT t.table_name::TEXT, 0::BIGINT, '–ù–µ–≤—ñ–¥–æ–º–æ'::TEXT, '–ë–∞–∑–æ–≤–∞ —Ç–∞–±–ª–∏—Ü—è'::TEXT
  FROM information_schema.tables t WHERE t.table_schema = 'public' AND t.table_type = 'BASE TABLE' ORDER BY t.table_name;
END; $$;

CREATE OR REPLACE FUNCTION public.get_simple_structure(table_name_param TEXT)
RETURNS TABLE (column_name TEXT, data_type TEXT, is_nullable TEXT, column_default TEXT, is_primary_key BOOLEAN, is_foreign_key BOOLEAN, foreign_table TEXT, foreign_column TEXT)
LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  RETURN QUERY SELECT c.column_name::TEXT, c.data_type::TEXT, c.is_nullable::TEXT, COALESCE(c.column_default, '')::TEXT, false::BOOLEAN, false::BOOLEAN, ''::TEXT, ''::TEXT
  FROM information_schema.columns c WHERE c.table_name = table_name_param AND c.table_schema = 'public' ORDER BY c.ordinal_position;
END; $$;

CREATE OR REPLACE FUNCTION public.get_simple_data(table_name_param TEXT, page_number INT DEFAULT 1, page_size INT DEFAULT 50)
RETURNS TABLE (data JSONB, total_count BIGINT, page_count INT)
LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE offset_val INT; sql_query TEXT; result_data JSONB; total_rows BIGINT;
BEGIN
  offset_val := (page_number - 1) * page_size;
  sql_query := format('SELECT json_agg(row_to_json(t.*)) FROM (SELECT * FROM %I LIMIT %s OFFSET %s) t', table_name_param, page_size, offset_val);
  EXECUTE sql_query INTO result_data;
  EXECUTE format('SELECT COUNT(*) FROM %I', table_name_param) INTO total_rows;
  RETURN QUERY SELECT COALESCE(result_data, '[]'::jsonb), total_rows, CEIL(total_rows::NUMERIC / page_size)::INT;
END; $$;

CREATE OR REPLACE FUNCTION public.get_all_functions()
RETURNS TABLE (function_name TEXT, arguments TEXT, return_type TEXT, language TEXT, function_type TEXT, description TEXT, source_code TEXT)
LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  RETURN QUERY SELECT p.proname::TEXT, pg_get_function_arguments(p.oid)::TEXT, pg_get_function_result(p.oid)::TEXT, l.lanname::TEXT,
    CASE WHEN p.prokind = 'f' THEN 'function' WHEN p.prokind = 'p' THEN 'procedure' ELSE 'other' END::TEXT,
    COALESCE(d.description, '–ù–µ–º–∞—î –æ–ø–∏—Å—É')::TEXT, COALESCE(p.prosrc, '–ö–æ–¥ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π')::TEXT
  FROM pg_proc p JOIN pg_namespace n ON p.pronamespace = n.oid JOIN pg_language l ON p.prolang = l.oid
  LEFT JOIN pg_description d ON d.objoid = p.oid WHERE n.nspname = 'public' AND l.lanname != 'c' ORDER BY p.proname;
END; $$;

-- 3. –ü–†–ê–í–ê –î–û–°–¢–£–ü–£
GRANT EXECUTE ON FUNCTION public.exec_sql(TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_simple_tables() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_simple_structure(TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_simple_data(TEXT, INT, INT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_all_functions() TO authenticated;

-- 4. –¢–ï–°–¢–£–í–ê–ù–ù–Ø
SELECT 'üéâ –í–°–ï –°–¢–í–û–†–ï–ù–û –£–°–ü–Ü–®–ù–û!' as status;
SELECT '–ö—ñ–ª—å–∫—ñ—Å—Ç—å —Ç–∞–±–ª–∏—Ü—å: ' || COUNT(*)::TEXT as tables_count FROM public.get_simple_tables();
SELECT '‚úÖ –ì–û–¢–û–í–û! –ü–µ—Ä–µ–π–¥—ñ—Ç—å –≤ Database Manager - —Ç–∞–±–ª–∏—Ü—ñ –º–∞—é—Ç—å –∑''—è–≤–∏—Ç–∏—Å—è!' as final_result;`
  };

  return contents[fileName] || `-- SQL file: ${fileName}
-- Content not available in demo mode
-- In production, this would load actual file content

SELECT 'File content would be loaded here' as demo_message;`;
}

export async function executeSQLFile(fileName: string, content: string): Promise<any> {
  // –†–ï–ê–õ–¨–ù–ï –í–ò–ö–û–ù–ê–ù–ù–Ø SQL –ß–ï–†–ï–ó SUPABASE
  const { supabase } = await import('@/integrations/supabase/client');
  
  const startTime = Date.now();
  
  try {
    // –°–ø—Ä–æ–±—É—î–º–æ –≤–∏–∫–æ–Ω–∞—Ç–∏ —á–µ—Ä–µ–∑ exec_sql —Ñ—É–Ω–∫—Ü—ñ—é
    const { data, error } = await supabase.rpc('exec_sql', {
      sql_query: content
    });
    
    const executionTime = Date.now() - startTime;
    
    if (error) {
      console.error('–ü–æ–º–∏–ª–∫–∞ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è SQL:', error);
      return {
        success: false,
        message: `–ü–æ–º–∏–ª–∫–∞ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è SQL: ${error.message}`,
        error: error.message,
        executionTime
      };
    }
    
    return {
      success: true,
      message: `SQL —Ñ–∞–π–ª ${fileName} –≤–∏–∫–æ–Ω–∞–Ω–æ —É—Å–ø—ñ—à–Ω–æ`,
      data: data,
      executionTime,
      rowsAffected: Array.isArray(data) ? data.length : 1
    };
    
  } catch (error: any) {
    const executionTime = Date.now() - startTime;
    console.error('–ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è SQL:', error);
    
    return {
      success: false,
      message: `–ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞: ${error.message}`,
      error: error.message,
      executionTime
    };
  }
}

export async function deleteSQLFile(fileName: string): Promise<void> {
  try {
    // –°–∏–º—É–ª—é—î–º–æ –∑–∞—Ç—Ä–∏–º–∫—É –≤–∏–¥–∞–ª–µ–Ω–Ω—è
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // –†—ñ–¥–∫—ñ—Å–Ω–∞ —Å–∏–º—É–ª—è—Ü—ñ—è –ø–æ–º–∏–ª–∫–∏ (5% –≤–∏–ø–∞–¥–∫—ñ–≤)
    if (Math.random() < 0.05) {
      throw new Error('–ù–µ –≤–¥–∞–ª–æ—Å—è –≤–∏–¥–∞–ª–∏—Ç–∏ —Ñ–∞–π–ª: —Ñ–∞–π–ª –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è —ñ–Ω—à–∏–º –ø—Ä–æ—Ü–µ—Å–æ–º');
    }

    // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Ñ–∞–π–ª —è–∫ –≤–∏–¥–∞–ª–µ–Ω–∏–π –≤ localStorage
    const deletedFiles = JSON.parse(localStorage.getItem('deletedSQLFiles') || '[]') as string[];
    
    if (!deletedFiles.includes(fileName)) {
      deletedFiles.push(fileName);
      localStorage.setItem('deletedSQLFiles', JSON.stringify(deletedFiles));
    }

    console.log(`–§–∞–π–ª ${fileName} –ø–æ–º—ñ—á–µ–Ω–æ —è–∫ –≤–∏–¥–∞–ª–µ–Ω–∏–π`);
  } catch (error) {
    console.error('–ü–æ–º–∏–ª–∫–∞ –≤–∏–¥–∞–ª–µ–Ω–Ω—è —Ñ–∞–π–ª—É:', error);
    throw error;
  }
}

// –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –≤—Å—ñ—Ö –≤–∏–¥–∞–ª–µ–Ω–∏—Ö —Ñ–∞–π–ª—ñ–≤ (–¥–ª—è —Ä–æ–∑—Ä–æ–±–∫–∏)
export function restoreAllDeletedFiles(): void {
  localStorage.removeItem('deletedSQLFiles');
  console.log('–í—Å—ñ –≤–∏–¥–∞–ª–µ–Ω—ñ —Ñ–∞–π–ª–∏ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–æ');
}

// –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Å–ø–∏—Å–∫—É –≤–∏–¥–∞–ª–µ–Ω–∏—Ö —Ñ–∞–π–ª—ñ–≤
export function getDeletedFiles(): string[] {
  return JSON.parse(localStorage.getItem('deletedSQLFiles') || '[]');
}